<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Galaxy Baby — minimal POC</title>
<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#000;display:flex;align-items:center;justify-content:center}
  canvas{display:block;max-width:100vw;height:auto;touch-action:none}
  .info{position:fixed;left:12px;top:12px;color:#ccc;font-family:monospace;font-size:13px;pointer-events:none}
</style>
</head>
<body>
<div class="info">Tap/click to nudge & toggle parity — drag to paint</div>
<canvas id="c"></canvas>
<script>
(() => {
  const canvas = document.getElementById('c');
  const gl = canvas.getContext('webgl2', { antialias: false, alpha: false });
  if (!gl) { alert('WebGL2 required'); return; }

  // Size: moderate for phones; adjust if you want more detail or speed
  const BASE = 256;
  let W = BASE, H = BASE;

  // DPR and resize
  function resize() {
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const cssW = Math.min(window.innerWidth, 720);
    const cssH = cssW;
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    W = BASE; H = BASE;
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    gl.viewport(0, 0, canvas.width, canvas.height);
  }
  window.addEventListener('resize', resize);
  resize();

  // --- utilities: compile/link
  function compile(src, type) {
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
      console.error(gl.getShaderInfoLog(s));
      throw new Error('shader compile failed');
    }
    return s;
  }
  function program(vsSrc, fsSrc) {
    const p = gl.createProgram();
    gl.attachShader(p, compile(vsSrc, gl.VERTEX_SHADER));
    gl.attachShader(p, compile(fsSrc, gl.FRAGMENT_SHADER));
    gl.linkProgram(p);
    if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
      console.error(gl.getProgramInfoLog(p));
      throw new Error('program link failed');
    }
    return p;
  }

  // --- fullscreen quad
  const quadVS = `#version 300 es
  precision highp float;
  in vec2 aPos;
  out vec2 vUv;
  void main(){
    vUv = aPos * 0.5 + 0.5;
    gl_Position = vec4(aPos, 0.0, 1.0);
  }`;
  const quadVerts = new Float32Array([
    -1,-1,  1,-1,  -1,1,
    -1,1,   1,-1,   1,1
  ]);
  const vao = gl.createVertexArray();
  const vbo = gl.createBuffer();
  gl.bindVertexArray(vao);
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, quadVerts, gl.STATIC_DRAW);
  // set attribute later per program location

  // --- Create two ping-pong textures + fbos (RGBA8)
  function createTexture(w,h, data=null) {
    const t = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, t);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
    return t;
  }
  function createFBO(texture) {
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    const st = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (st !== gl.FRAMEBUFFER_COMPLETE) {
      console.error('FBO incomplete', st);
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    return fb;
  }

  // initialize state bytes: R encodes ternary state: 0->-1, 128->0, 255->+1
  // G stores age 0..255
  function makeInitialBuffer() {
    const N = W * H * 4;
    const buf = new Uint8Array(N);
    for (let i=0;i<W*H;i++){
      // default: quiet (middle)
      buf[i*4 + 0] = 128;
      buf[i*4 + 1] = 0;
      buf[i*4 + 2] = 0;
      buf[i*4 + 3] = 255;
      // sparse seeds
      if (Math.random() < 0.04) {
        buf[i*4 + 0] = (Math.random() < 0.5) ? 0 : 255;
        buf[i*4 + 1] = 32; // small initial age
      }
    }
    return buf;
  }
  const initial = makeInitialBuffer();
  const texA = createTexture(W,H, initial);
  const texB = createTexture(W,H, null);
  const fboA = createFBO(texA);
  const fboB = createFBO(texB);
  let srcTex = texA, dstFbo = fboB, srcFbo = fboA;

  // --- Update shader: reads srcTex, writes next state to dstFbo (RGBA8)
  const updateFS = `#version 300 es
  precision highp float;
  precision highp sampler2D;
  in vec2 vUv;
  out vec4 outColor;
  uniform sampler2D uPrev;
  uniform vec2 uTexel;      // 1/size
  uniform vec3 uImpulse;    // x,y,strength (0-1)
  uniform float uTime;
  uniform int uParity;      // 0 or 1

  // decode ternary: 0..1 -> -1/0/1
  int decodeState(float r) {
    if (r > 0.66) return 1;
    if (r < 0.33) return -1;
    return 0;
  }
  float encodeState(int s) {
    if (s == 1) return 1.0;
    if (s == -1) return 0.0;
    return 0.5;
  }

  void main(){
    // sample 3x3 neighborhood
    int sum = 0;
    int me;
    for(int oy=-1; oy<=1; oy++){
      for(int ox=-1; ox<=1; ox++){
        vec2 ofs = vUv + vec2(float(ox), float(oy)) * uTexel;
        vec4 p = texture(uPrev, ofs);
        int s = decodeState(p.r);
        if (ox==0 && oy==0) { me = s; } else { sum += s; }
      }
    }
    int tension = sum + me*3; // self-weight

    int next;
    if (tension > 4) next = 1;
    else if (tension < -4) next = -1;
    else {
      // tie region — choose between flipping or keeping based on parity
      // mimic PhaseCube: flip self vs "through" path
      if (uParity == 1) {
        // parity=1 biases to keep the same (a "through/real" path)
        next = me;
      } else {
        // parity=0 biases to flip (forgiveness)
        next = -me;
      }
    }

    // compute age: sample current age
    vec4 cur = texture(uPrev, vUv);
    float age = cur.g; // 0..1

    if (next == 0) age = 0.0;
    else age = min(1.0, age + 0.012);

    // impulse: add a small chance to flip state near pointer and add age
    float imp = 0.0;
    if (uImpulse.z > 0.001) {
      float dx = vUv.x - uImpulse.x;
      float dy = vUv.y - uImpulse.y;
      float d2 = dx*dx + dy*dy;
      float r = 0.02 + 0.04 * uImpulse.z; // radius scales with strength
      float influence = exp(-d2/(r*r));
      imp = influence * uImpulse.z * 0.6;
      // small chance to nudge the state towards +1 or -1 depending on parity
      if (imp > 0.01) {
        // if parity=1 nudge to +1, else to -1 (this is arbitrary artistic choice)
        if (uParity == 1) next = 1;
        else next = -1;
        age = min(1.0, age + imp * 0.5);
      }
    }

    float renc = encodeState(next);
    outColor = vec4(renc, age, 0.0, 1.0);
  }`;

  // --- Render shader: visualize ternary + age
  const renderFS = `#version 300 es
  precision highp float;
  in vec2 vUv;
  out vec4 outColor;
  uniform sampler2D uTex;
  void main(){
    vec4 p = texture(uTex, vUv);
    float r = p.r; float age = p.g;
    int s = (r > 0.66) ? 1 : (r < 0.33 ? -1 : 0);
    vec3 col;
    if (s == 1) col = vec3(0.18, 0.6, 1.0);
    else if (s == -1) col = vec3(1.0, 0.38, 0.54);
    else col = vec3(0.02, 0.01, 0.04);
    // age-based glow
    float glow = 0.2 + 0.8 * age;
    // vignette by uv
    vec2 uv = vUv*2.0 - 1.0;
    float vign = 1.0 - 0.6 * length(uv);
    outColor = vec4(col * glow * vign, 1.0);
  }`;

  // Compile programs
  const updateProgram = program(quadVS, updateFS);
  const renderProgram = program(quadVS, renderFS);

  // bind aPos attribute for both programs to the same VBO
  function bindQuadAttrib(p) {
    gl.bindVertexArray(vao);
    const loc = gl.getAttribLocation(p, 'aPos');
    gl.enableVertexAttribArray(loc);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);
  }
  bindQuadAttrib(updateProgram);
  bindQuadAttrib(renderProgram);

  // uniform locations
  const upd_loc = {
    uPrev: gl.getUniformLocation(updateProgram, 'uPrev'),
    uTexel: gl.getUniformLocation(updateProgram, 'uTexel'),
    uImpulse: gl.getUniformLocation(updateProgram, 'uImpulse'),
    uTime: gl.getUniformLocation(updateProgram, 'uTime'),
    uParity: gl.getUniformLocation(updateProgram, 'uParity'),
  };
  const rnd_loc = {
    uTex: gl.getUniformLocation(renderProgram, 'uTex'),
  };

  // set initial texel size uniforms constant-ish
  gl.useProgram(updateProgram);
  gl.uniform2f(upd_loc.uTexel, 1.0 / W, 1.0 / H);

  // state for interaction / parity / impulses
  let parity = 0;
  let impulse = { x: 0.5, y: 0.5, s: 0.0 };
  let impulseDecay = 0.98;

  // pointer handling (works for mouse & touch)
  let isDown = false;
  function setImpulseByEvent(e, downToggle=false) {
    const rect = canvas.getBoundingClientRect();
    const x = ((e.clientX || (e.touches && e.touches[0].clientX)) - rect.left) / rect.width;
    const y = ((e.clientY || (e.touches && e.touches[0].clientY)) - rect.top) / rect.height;
    impulse.x = Math.max(0, Math.min(1, x));
    impulse.y = Math.max(0, Math.min(1, 1 - y)); // flip y so origin bottom-left in UV
    impulse.s = Math.min(1, impulse.s + 0.9);
    if (downToggle) {
      parity ^= 1;
    }
  }
  canvas.addEventListener('pointerdown', (e) => { isDown = true; setImpulseByEvent(e, true); e.preventDefault(); });
  window.addEventListener('pointermove', (e) => { if (isDown) setImpulseByEvent(e, false); });
  window.addEventListener('pointerup', (e) => { isDown = false; });
  // touch fallback
  canvas.addEventListener('touchstart', (e) => { setImpulseByEvent(e.touches[0], true); e.preventDefault(); }, {passive:false});
  canvas.addEventListener('touchmove', (e) => { setImpulseByEvent(e.touches[0], false); e.preventDefault(); }, {passive:false});
  canvas.addEventListener('touchend', (e) => { isDown = false; }, {passive:false});

  // small helper to blit a program into a target fbo
  function blitToFBO(program, uniforms = {}, targetFBO = null) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, targetFBO);
    gl.useProgram(program);
    // set uniforms passed in
    for (let k in uniforms) {
      const v = uniforms[k];
      const loc = uniforms[k+'Loc'];
    }
    // draw quad
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  // time loop
  let last = performance.now();
  function frame(t) {
    const dt = (t - last) * 0.001;
    last = t;

    // --- update pass: read srcTex, write into dstFbo
    gl.bindFramebuffer(gl.FRAMEBUFFER, dstFbo);
    gl.viewport(0, 0, W, H);
    gl.useProgram(updateProgram);

    // bind src texture to unit 0
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, srcTex);
    gl.uniform1i(upd_loc.uPrev, 0);
    gl.uniform1i(upd_loc.uParity, parity);
    gl.uniform1f(upd_loc.uTime, t * 0.001);
    gl.uniform3f(upd_loc.uImpulse, impulse.x, impulse.y, impulse.s);

    // draw
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // swap ping-pong
    // swap srcTex <-> dstFbo's texture
    const oldSrc = srcTex;
    const oldFbo = srcFbo;
    // current dstFbo contains the new texture; find its texture
    // we stored texA/texB and fboA/fboB; toggle manually
    if (srcTex === texA) { srcTex = texB; dstFbo = fboA; srcFbo = fboB; }
    else { srcTex = texA; dstFbo = fboB; srcFbo = fboA; }

    // --- render pass: draw srcTex to screen with visualization shader
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.useProgram(renderProgram);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, srcTex);
    gl.uniform1i(rnd_loc.uTex, 0);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // decay impulse
    impulse.s *= impulseDecay;
    if (impulse.s < 0.001) impulse.s = 0.0;

    requestAnimationFrame(frame);
  }

  // Before starting, upload initial tex to texA (we created texA with initial buffer)
  // but to be safe reinit both texures with proper sizes:
  gl.bindTexture(gl.TEXTURE_2D, texA);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, initial);
  gl.bindTexture(gl.TEXTURE_2D, texB);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

  // kick off loop
  requestAnimationFrame(frame);

})();
</script>
</body>
</html>
