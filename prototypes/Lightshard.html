<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>lightshard.cu → WebGPU • They Hear You</title>
  <style>
    body{margin:0;background:#000;overflow:hidden}
    canvas{display:block}
    #info{position:fixed;top:10px;left:10px;color:#0ff;font-family:monospace;background:rgba(0,0,0,0.6);padding:8px;border-radius:6px;font-size:13px}
  </style>
</head>
<body>
<div id="info">lightshard.cu reborn • 131072 shards • speak, sing, breathe</div>
<canvas id="c"></canvas>

<script type="module">
if (!navigator.gpu) { alert("WebGPU not available"); throw ""; }

const canvas = document.getElementById('c');
const adapter = await navigator.gpu.requestAdapter();
const device = await adapter.requestDevice();
const context = canvas.getContext('webgpu');
const format = navigator.gpu.getPreferredCanvasFormat();
context.configure({ device, format });

const SHARDS = 131072;
const WG_SIZE = 256;

// Your sacred kernel — 1:1 translation of lightshard.cu
const computeWGSL = `
@binding(0) @group(0) var<storage, read_write> pos : array<vec4f>;
@binding(1) @group(0) var<storage, read_write> phase : array<f32>;
@binding(2) @group(0) var<uniform> params : vec4f; // t, mouseX, mouseY, audio

@compute @workgroup_size(${WG_SIZE})
fn paradox_step(@builtin(global_invocation_id) id : vec3u) {
  let i = id.x;
  if (i >= ${SHARDS}u) { return; }

  var p = pos[i].xyz;
  var ph = phase[i];

  // paradox core — one sine, no branches
  let paradox = sin(ph + params.x * 0.7 + fract(sin(f32(i)*0.001)*1000.0)*0.02);

  // dynamic center + mouse + audio kick
  let center = vec3f(
    sin(params.x * 0.11) * 4.0 + (params.y - 0.5) * 12.0,
    cos(params.x * 0.13) * 3.0 + (params.z - 0.5) * 10.0,
    sin(params.x * 0.17) * 3.0
  );
  let force = normalize(center - p) * select(-1.2, 1.2, paradox > 0.0) * (0.6 + params.w * 8.0);

  // zeno damping + leapfrog
  p += p * 0.999 - p * 0.001 + force * 0.0012;

  // toroidal universe
  p = fract((p + 10.0) * 0.05) * 20.0 - 10.0;

  pos[i] = vec4f(p, 1.0);
  phase[i] = ph + 0.01337 + sin(params.x * 0.1) * 0.002;
}
`;

// Point cloud renderer
const renderWGSL = `
struct VertexOut {
  @builtin(position) pos : vec4f,
  @location(0) color : vec4f,
};

@binding(0) @group(0) var<storage> pos : array<vec4f>;

@vertex
fn vs(@builtin(vertex_index) i : u32) -> VertexOut {
  let p = pos[i].xyz;
  var out : VertexOut;
  out.pos = vec4f(p.x * 0.08, p.y * 0.08, 0.0, 1.0);
  let hue = fract(pos[i].w + sin(p.x*0.1 + p.z*0.1) * 0.5) * 6.28;
  out.color = vec4f(abs(sin(hue)), abs(sin(hue+2.09)), abs(sin(hue+4.18)), 0.9);
  return out;
}

@fragment
fn fs(in : VertexOut) -> @location(0) vec4f {
  return in.color;
}
`;

// Buffers
const posBuffer = device.createBuffer({
  size: SHARDS * 16,
  usage: GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX,
  mappedAtCreation: true
});
const phaseBuffer = device.createBuffer({
  size: SHARDS * 4,
  usage: GPUBufferUsage.STORAGE
});

// Init: sphere of light babies
const posArray = new Float32Array(SHARDS * 4);
const phaseArray = new Float32Array(SHARDS);
for (let i = 0; i < SHARDS; i++) {
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.acos(Math.random() * 2 - 1);
  const r = Math.cbrt(Math.random()) * 4;
  posArray[i*4]   = r * Math.sin(phi) * Math.cos(theta);
  posArray[i*4+1] = r * Math.sin(phi) * Math.sin(theta);
  posArray[i*4+2] = r * Math.cos(phi);
  posArray[i*4+3] = 1;
  phaseArray[i] = Math.random() * 6.28;
}
posBuffer.unmap();
device.queue.writeBuffer(posBuffer, 0, posArray);
device.queue.writeBuffer(phaseBuffer, 0, phaseArray);

// Pipelines
const computePipeline = device.createComputePipeline({
  layout: 'auto',
  compute: { module: device.createShaderModule({code: computeWGSL}), entryPoint: 'paradox_step' }
});

const renderPipeline = device.createRenderPipeline({
  layout: 'auto',
  vertex: { module: device.createShaderModule({code: renderWGSL}), entryPoint: 'vs' },
  fragment: { module: device.createShaderModule({code: renderWGSL}), entryPoint: 'fs', targets: [{format}] },
  primitive: { topology: 'point-list' }
});

// Audio
let audioEnergy = 0;
async function enableEars() {
  const stream = await navigator.mediaDevices.getUserMedia({audio:true});
  const ctx = new AudioContext();
  const analyser = ctx.createAnalyser();
  analyser.fftSize = 512;
  ctx.createMediaStreamSource(stream).connect(analyser);
  const data = new Uint8Array(analyser.frequencyBinCount);
  const tick = () => {
    analyser.getByteFrequencyData(data);
    audioEnergy = data.reduce((a,b)=>a+b,0) / data.length / 255;
    requestAnimationFrame(tick);
  };
  tick();
}
enableEars().catch(()=>{});

// Resize
function resize() {
  canvas.width = canvas.clientWidth * devicePixelRatio;
  canvas.height = canvas.clientHeight * devicePixelRatio;
}
window.addEventListener('resize', resize);
resize();

// Mouse
let mx = 0.5, my = 0.5;
canvas.addEventListener('mousemove', e => {
  mx = e.clientX / canvas.clientWidth;
  my = e.clientY / canvas.clientHeight;
});

// Animation
let t = 0;
function frame() {
  const encoder = device.createCommandEncoder();

  // Update
  const uniform = new Float32Array([t, mx, my, audioEnergy]);
  const paramBuffer = device.createBuffer({
    size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });
  device.queue.writeBuffer(paramBuffer, 0, uniform);

  const computePass = encoder.beginComputePass();
  computePass.setPipeline(computePipeline);
  computePass.setBindGroup(0, device.createBindGroup({
    layout: computePipeline.getBindGroupLayout(0),
    entries: [
      {binding:0, resource:{buffer:posBuffer}},
      {binding:1, resource:{buffer:phaseBuffer}},
      {binding:2, resource:{buffer:paramBuffer}}
    ]
  }));
  computePass.dispatchWorkgroups(Math.ceil(SHARDS / WG_SIZE));
  computePass.end();

  // Render
  const view = context.getCurrentTexture().createView();
  const renderPass = encoder.beginRenderPass({
    colorAttachments: [{view, clearValue:[0,0,0,1], loadOp:'clear', storeOp:'store'}]
  });
  renderPass.setPipeline(renderPipeline);
  renderPass.setBindGroup(0, device.createBindGroup({
    layout: renderPipeline.getBindGroupLayout(0),
    entries: [{binding:0, resource:{buffer:posBuffer}}]
  }));
  renderPass.setVertexBuffer(0, posBuffer);
  renderPass.draw(SHARDS);
  renderPass.end();

  device.queue.submit([encoder.finish()]);
  t += 0.016;
  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
